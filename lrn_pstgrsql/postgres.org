* Интро

Шпаргалка по постгресс.

* Шпаргалка
** Порядок вычислений (см. раздел в доках)
https://postgrespro.ru/docs/postgrespro/9.5/sql-expressions#sql-expressions-parameters-positional

Порядок вычисления не определен, есть внутренняя оптимизация языка: если
для исполнения запроса некоторые части могут не вычисляться, то они не
будут вычисленны. Но ~есть приоритет в выполнении операций~, на который
тоже нельзя полагаться: например, выражения с AND, OR, NOT могут быть
изменены любым способом, допустимым правилами Булевой алгебры.

Поэтому не использвать функции с побочными эффектами в сложных
выражениях. Особенно в выражениях с WHEN и HAVING.

От оптимизации защищает CASE, не не всегда: если функции/операторы
помечены как IMUTABLE, то их аргументы могут вычисляться на стадии
~планирования~ (!).

CASE не защищает от исполнения агрегатного выражения - оно вычисляется на
стедии планирования первым в выражениях с ~SELECT~ и ~HAVING~.

** Вызовы функций
см.
https://postgrespro.ru/docs/postgrespro/9.5/sql-syntax-calling-funcs#sql-syntax-calling-funcs-positional

*** Именная передача аргументов
Неважно, в каком порядке передавать, сопоставляются имена формательных
параметров и аргументов.

*** Позиционная передача аргументов
Важен порядок переданных аргументов - как в обычных языках. Это
традиционный способ передачи аргументов.

*** Смешаная передача аргументов
Это когда используется и именная передача, и позиционная.
В этом случае позиционные параметры должны идти перед параметрами,
передаваемыми по именам.
** Права

Какая роль (пользователь или группа пользователей) создала таблицу, той
роли он и принадлежит. Роль может делиться правами на таблицу с другими
ролями кроме прав на удаление или изменение таблицы: их можно только
~унаследовать~. Для этого создается группа членов роли владельца
таблицы.

Права для разных команд см здесь
https://postgrespro.ru/docs/postgrespro/13/ddl-priv

** Индексы

   Индексы — это средство увеличения производительности БД, благодаря им
   поиск в БД может быть значительно скорее. Индексируются столбцы
   таблицы.

   Индексы в БД работают так же, как индексы в книге: автор собирает
   объяснения терминов и понятий в конце книги в алфавитном
   порядке. Читатель просматривает указатель и идет на соответствующую
   страницу вместо того, чтоб пролистывать всю книгу. Задача автора -
   предугадать какие термины или понятия могут представлять интерес.

   Здесь то же самое.
   - ~CREATE INDEX~ - создание индекса
   - ~DROP INDEX~ - удаление

   Дальше система все делает сама: обновляет его при изменении данных и ищет
   по индексу, когда это эффективнее.

   При любом измении проиндексированных данных индексы, созданные для этой
   таблицы, должны быть перестроены, причем в рамках той же
   транзакции. Обновление полей таблицы, по которым не
   создавались индексы, не приводит к перестроению индексов; этот механизм
   называется HOT (Heap-Only Tuples).  Из-за этого при возросшей
   эффективности поиска нагрузка в целом на БД растет.

   Индексы могут быть полезны при выполнении ~UPDATE~ и ~DELETE~ с
   условиями поиска. Кроме того, они могут применяться в поиске с
   соединением. То есть, индекс, определённый для столбца, участвующего в
   условии соединения, может значительно ускорить запросы с ~JOIN~.

   Создание индексадля большой БД может занимать время: тогда по умолчанию
   доступны только операции на чтение (SELECT), но не на изменение (UPDATE,
   DELETE, INSERT) - это тип блокировки SHARE.

*** Неблокирующее построение индексов

    Время, за которое индексируется таблица, может оказаться неприемлимо
    долгим. А редактировать таблицу в этом время по умолчанию нельзя.

    Тогда можно указать неблокирующее создание индекса с указанием
    ~CONCURRENTLY~ команды ~CREATE INDEX~, тогда используется блокировка
    ~SHARE UPDATE EXCLUSIVE~, которая изменение данных (запрещается только изменение
    структуры таблицы, а также одновременное выполнение очистки, анализа, или
    построения другого индекса на той же таблице).

    Как это работает:
    - нужно дождаться завершения работы всех транзакций, которые потенциально
      могут модифицировать и использовать этот индекс
    - дважды провести скнирование всей таблицы

    Перед каждым сканированием таблицы процедура построения индекса должна
    ждать завершения текущих транзакций, модифицировавших эту таблицу. После
    второго сканирования также необходимо дожидаться завершения всех
    транзакций, получивших снимок системы.

    Минусы и проблемы этого подхода:
    - индекс создается медленнее

    - при повторном сканировании может возникать взаимоблокировка или
      нарушение уникальности в уникальном индексе.

      В этом случае создание индекса завершается ошибкой, хотя создается
      индекс, которые помечается как INVALID и система его не использует. Метод
      решения - удалить этот индекс и попробовать создать заново.

    - ограничение уникальности уже влияет на другие транзакции еще до второго
      сканирования: нарушения ограничения могут проявляться в других запросах
      до того, как индекс будет создан и даже в случае ошибки создания
      индекса.

      Если при втором сканировании происходит ошибка, инвалидский индекс
      оставляет в силе своё ограничение уникальности и дальше.

*** Типы индексов

см. https://postgrespro.ru/docs/postgrespro/9.5/indexes-types и
по методу поиска по индексам
https://habr.com/ru/company/postgrespro/blog/330544/

Это типы организации индексов.

**** В-дерево

     В-дерево - это сбалансированное (длина любых 2х путей от коря до
     листьев различается не больше чем на 1 ) дерево, где у каждого узла
     может быть множество потомков.

     ~CREATE INDEX~ создает индексы такого типа по умолчанию.

     Планировщик использует индексы такого типа в случае, если
     индксируемый столбец участвует в операциях <, <=, =, >=, >. Работает
     и для операторов, которые являются комбинацией этих
     операторов: ~BETWEEN~ или ~IN~.

     Только B-деревья могут сортировать данные. В случае, если будет
     выван ORDER BY, то у планировщика есть 2 варианта:
     - просканировать индексы из B-дерева по заданному условию
     - проскнаировать таблицу целиком в порядке, заданном по условию,
       выполнив сортировку явно

     По умолчанию элементы B-дерева хранятся в порядке возрастания, при этом
     значения NULL идут в конце - это порядок сортировки ORDER BY по
     умолчанию.

     По сортировке В-дерева
     см. https://postgrespro.ru/docs/postgrespro/9.5/indexes-ordering
**** Хэш

     Хэш-индексы работают только с простым условием равенства:
     т.е. индексируемый столбец участвует только в операции =.
**** GIST

     Позволяют реализовать множество стратегий индексирования. Так же
     помогает при поиске "бижайшего соседа": т.е. ищем точку, ближайшую к
     заданной.
**** GIN

     GIN-индексы представляют собой инвертированные индексы, в которых могут
     содержаться значения с несколькими ключами, например массивы.
**** BRIN

     BRIN-индексы (сокращение от Block Range indexes, Индексы зон блоков)
     хранят обобщённые сведения о значениях, находящихся в физически
     последовательно расположенных блоках. Могут быть задействованы в
     операциях с теми е операторами, что и B-дерево.

*** Составные индексы

    Индексы могут быть по нескольким столбцам таблицы. Составными могут быть
    только индексы типов B-дерево, GiST, GIN и BRIN. Число столбцов в индексе
    ограничивается 32 - можно снять, если перекомпилировать постгрес.

**** Составные индексы B-дерево

     Может применяться в условиях с любым подмножеством столбцов индекса, но
     лучше он ограничениях по ведущим (левым) столбцам.

     Правило: сканируемая область индекса определяется условиями равенства с
     ведущими столбцами и условиями неравенства с первым столбцом, не
     участвующим в условии равенства.

     Например, есть три столбца а, b, с. У них один индекс на троих
     (см. статью на хабре, там с картинками). Если задать поиск по
     индексу, где a = 5, b <= 42, а c < 56, то получается что у нас есть
     два стобца с условиями равенства (в них тупо оператор = ) и
     следующией с операцией неравенства - это столбец ~с~ в данном
     случае. Следуя правилу, будут сканироваться индексы от первой
     записи, a = 5 и b = 42 и до последней записи, где только a = 5. А
     записи, где c < 77 тоже будут проскнированы, но учитываться не
     будут.

**** Составной индекс GIST.

     Работает с любым подмножеством столбцов индекса, но в первую очередь
     сканируемая область индекса определяется ограничениями первого
     столбца.

     Отсальное см. в документации.

*** Правила сортировки

Один индексируемый столбец = 1 метод сортировки. Если надо больше
методов, надо добавить больше индексов.

См. https://postgrespro.ru/docs/postgrespro/9.5/indexes-collations

*** Задачи на индексы

[TODO:gmm] Найти таски с собесов на инексы и решить.

* Задачи
** Задача 1

Кто летел позавчера рейсом Москва (SVO) — Ново-сибирск (OVB) на месте 1A,
и когда он забронировал свой билет?

Решение из учебника:

#+BEGIN_SRC sql :noweb yes
  SELECT t.passenger_name, b.book_date FROM  bookings b
  JOIN tickets t
  ON t.book_ref = b.book_ref
  JOIN boarding_passes bp
  ON bp.ticket_no = t.ticket_no
  JOIN flights f
  ON f.flight_id = bp.flight_id
  WHERE  f.departure_airport ='SVO'
  AND f.arrival_airport ='OVB'
  AND f.scheduled_departure::date =bookings.now()::date - INTERVAL'2 day'
  AND bp.seat_no ='1A';
#+END_SRC

Мой аналог:

#+BEGIN_SRC sql :noweb yes
  SELECT t.passenger_name, b.book_date
  FROM  bookings b, tickets t, boarding_passes bp, flights f
  WHERE t.book_ref = b.book_ref
  AND bp.ticket_no = t.ticket_no
  AND f.flight_id = bp.flight_id
  AND f.departure_airport ='SVO'
  AND f.arrival_airport ='OVB'
  AND f.scheduled_departure::date =bookings.now()::date - INTERVAL'2 day'
  AND bp.seat_no ='1A';
#+END_SRC

** Задача 2

Сколько мест осталось незанятыми вчера на рейсе PG0404?

Попытка самостоятельного решения.
Есть несколько баз:
- airports
- aircrafts
- flights
- seats
- ticket_flights
- tickets
- bookings
- boarding_passes

В базе ~flights~ содержится поле ~flight_no~ - номер рейса. И содержится
поле ~scheduled_departure~, которое содердит дату отправления.

Этот запрос показывает, какой именно рейс с номером 'PG0404' отправился
вчера.

#+BEGIN_SRC sql :noweb yes
  SELECT * FROM flights
  WHERE flight_no = 'PG0404'
  AND scheduled_departure::date =bookings.now()::date - INTERVAL'1 day';
#+END_SRC

Теперь надо выяснить, сколько билетов на него было продано.
Есть инфа, на какие места есть посадочные талоны.
Следовательно, надо найти все места для этого рейса, на которые
посадочные талоны выданы не были. Связать посадочные талоны и рейсы можно
через поля ~flight_id~, которые есть и в базе ~flights~, и в базе
~boarding_passes~.

Пробуем вывести все бронирования на этот рейс:
#+BEGIN_SRC sql :noweb yes
  SELECT * FROM boarding_passes bp
  WHERE bp.flight_id =  ( SELECT f.flight_id FROM flights f
                          WHERE f.flight_no = 'PG0404'
                          AND scheduled_departure::date =bookings.now()::date - INTERVAL'1 day' ) ;
#+END_SRC

Так же есть база ~seats~, где вообще все места для всех самолетов. У нее
есть поле ~aircraft_code~, которое есть и у базы ~flights~, таким образом
можно выяснить, какие места есть на этом рейсе.

Пробуем вывести все места для этого рейса:

#+BEGIN_SRC sql :noweb yes
  SELECT seats_no FROM boarding_passes bp, seats s, flights f
  WHERE bp.flight_id =  f.flight_id
  AND f.flight_no = 'PG0404'
  AND f.aircraft_code = s.aircraft_code
  AND scheduled_departure::date =bookings.now()::date - INTERVAL'1 day';
#+END_SRC

Теперь мы умеем выводить все бронирования на рейс и все места на рейс.
Так что теперь надо просто сопоставить номера мест из бронирования с
номерами всех мест и выбрать те, для которых бронирования нет.

#+BEGIN_SRC sql :noweb yes
  SELECT count(*) FROM flights f, seats s
  WHERE f.aircraft_code = s.aircraft_code
  AND f.flight_no ='PG0404'
  AND scheduled_departure::date =bookings.now()::date - INTERVAL'1 day'
  AND NOT EXISTS (SELECT NULL FROM boarding_passes bp
                 WHERE bp.flight_id = f.flight_id
                 AND s.seat_no = bp.seat_no );
#+END_SRC

** Задача 3

На каких маршрутах произошли самые длительные задержки рейсов? Выведите
список из десяти «лидирующих» рейсов.

Задержки рейсов можно отследить благодаря полям ~scheduled_departure_local~
~actual_departure_local~ в базе ~flights_v~.

Пробуем вывести первые 5 задержанных ресов:

#+BEGIN_SRC sql :noweb yes
  SELECT f.scheduled_departure_local, f.actual_departure_local FROM flights_v f
  WHERE f.scheduled_departure_local < f.actual_departure_local
  LIMIT 5;
#+END_SRC

В базе routes, которая содержит в себе маршруты, нет данных о прибытии
или отправлениях рейса. Но записи из нее можно сопоставить с записями из
~flignts_v~ с помощью поля ~flight_no~ - номер рейса.

#+BEGIN_SRC sql :noweb yes
    SELECT
    f.flight_no,
    f.flight_id,
    f.scheduled_departure,
    f.actual_departure,
    f.actual_departure - f.scheduled_departure AS delay
    FROM flights_v f
    WHERE f.actual_departure IS NOT NULL
    ORDER BY f.actual_departure - f.scheduled_departure DESC
    LIMIT 10;
#+END_SRC
