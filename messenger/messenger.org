#+STARTUP: showall indent hidestars

* Интро
Идея простая: переписать свой старый консольный мессенджер с си на
го. При этом добавить шифрование, поддержку множества клиентов и какойто
интерфейс.

* Механизм работы
** Клиент

Нужно организовать пересылку сообщения от конкретного клиента к
конкретному клиенту. Т.е. у каждого клиента - зарегистрированного
пользователя -  должен быть уникальный id, который не будет меняться от
подключения к подключению.

Подключенные пакеты:

#+NAME: _packages
#+BEGIN_SRC go :noweb yes :tangle client.go
  package main

  import (
      "fmt"
      "net"
      // "sync"
      "os"
      "strconv"
      "encoding/json"
      "bufio"
  )

  <<_sendPackage>>
  <<_myID>>
#+END_SRC

Структура пакета клиента для отправки:
- id юзера, ~который отправляет~
- id юзера, ~которому отрпавляют~
- буфер, в котором содержится сообщение
- статус отправки сообщения

Пока что уникальный id клиента вводится самим пользователем при запуске клиента -
параметр командной строки. Т.е. id может меняться от запуска к запуску.

[TODO:gmm] Сделать обработчик ошибок отправки и зарезервировать константы
под значения ошибок.

#+NAME: _sendPackage
#+BEGIN_SRC go :noweb yes
  type sendPackage struct {

      MyID int
      UserID int
      Message []string
      SendStatus int
  }

#+END_SRC

На данный момент ID клиента задается как аргумент командной строки при
запуске клиента. Поэтому заводим на стороне клиента глобальную переменную
и функцию, которая вытащит id клиента из аргументов командной строки и
поместит в переменную:

#+NAME: _myID
#+BEGIN_SRC go :noweb yes
  var myID int

  <<_consts>>
  <<_ChatTable>>
#+END_SRC


#+NAME: _GetClientId
#+BEGIN_SRC go :noweb yes :tangle client.go
  func GetClientId() error {

      id, err := strconv.Atoi( os.Args[1] )

      if err != nil {
          return err

      } else {
          myID = id
      }
      return nil
  }
#+END_SRC

Заводим константы: кол-во строк, которое вмещается в буфер, тестовый id
принимающего юзера, которому отправляется пакет, и размер буфера:

[TODO:gmm] как установить размер буфера, чтоб в него влез любой пакет?
(возможно, если пакет слишком большой - т.е. сообщение слишком большое -
оно должно быть разделено на n пакетов машиной?)

#+NAME: _consts
#+BEGIN_SRC go :noweb yes
  const (
      packSize = 1036
      msgSizeStrings = 10
  )
#+END_SRC

Функция, которая считывает вывод с консоли строка за строкой, пока не
встретит строку ~"stop"~ - это является сигналом, что считывание надо
прекратить. В случае, если считывается ~"quit"~, то это сигнал, что
клиент хочет завершить работу.

В этом случае будет отправлено сообщение серверу с соответствующим
статусом, что соединение можно отключить.

#+NAME: _getInput
#+BEGIN_SRC go :noweb yes
  func getInput () ( []string, int ) {

      r := bufio.NewReader( os.Stdin )
      input:= make( []string, msgSizeStrings )
      inputStatus := 0

      for i := range input {
          string, err := r.ReadString('\n')

          if err != nil {
              fmt.Printf("getInput: Didn't read string \n")
              break

          } else if string == "stop\n" {
              break

          } else if string == "quit\n" {
              inputStatus = -5
              break
          } else {
              input[i] = string
          }
      }

      // for i := range input{
      // 	fmt.Printf("Read: %s \n", input[i])
      // }

      return input, inputStatus
  }

  <<_makePackage>>
#+END_SRC

Как только считывание прекращено, формируем пакет на отправку:
- парсим ввод
- формируем пакет

Пока что считаем, что первой строкой юзер вводит id клиента, которому
хочет послать пакет (в финальной версии юзер будет переключаться между
окнами в браузере )

[TODO:gmm] Что насчет бесед, в которх больше 2 участников?

#+NAME: _makePackage
#+BEGIN_SRC go :noweb yes
  func makePackage ( input []string, clientStatus int) ( sendPackage, error ) {

      // убираем '\n' после числа
      string := input[0]
      n :=  len(string) - 1

      RecieverUserID, err := strconv.Atoi( string[:n] )
      pack := sendPackage{}
      if err != nil {
          fmt.Printf("makePackage: Didn't convert id of user: ", err.Error(), "\n")

      } else {
          pack.MyID = myID
          pack.UserID = RecieverUserID
          pack.Message = input [1:]
          pack.SendStatus = clientStatus

      }
      return pack, err
  }
#+END_SRC

Открываем сокет типа TCP и коннектимся к серверу (у сервака и клиентов
должен быть один и тот же порт (?))

Возвращаем структуру соеднения ~conn~ и ~nil~ как значение ошибки в
сулчае успеха. Иначе печатаем сообщение об ошибке, вместо ~conn~
возвращаем ~nil~ и саму ошибку.

#+NAME: _ConnectToServer
#+BEGIN_SRC go :noweb yes :tangle client.go
  func ConnectToServer() ( *net.TCPConn, error ) {

      serVaddr :=  "localhost:3425"
      tcpAddr, err := net.ResolveTCPAddr("tcp", serVaddr)

      if err != nil {
          println("ResolveTCPAddr failed:", err.Error())
          return nil, err

      } else {

          // fmt.Printf( "Client tcp addr: %v \n",  tcpAddr)
          connect , err := net.DialTCP( "tcp", nil, tcpAddr)

          if err != nil {
              fmt.Printf( "Connection failed: ", err.Error(), "\n" )
              return nil, err
          }
          return connect, nil
      }
  }

  <<_getMessage>>
  <<_sendMessage>>
#+END_SRC

Коннект к серверу вызывается из мэйна. Если коннект совершился, то в цикле:
- читаем сообщение юзера с консоли
- парсим (вытаскиваем id юзера, которому отправляется пакет ) и формируем
  пакет на отправку
- проверяем id юзера - принимающей стороны, открыты ли под него потоки на
  отправку и на получение пакетов.

Идея в том, что на каждй чат полагается своя пара потоков на получение и
отправку сообщений. Иначе будет невозможно писать нескольким юзерам
одновременно, как и принимать от них сообщения. Потоки не будут напрямую
связаны с каким-то конкретным чатом. Пакеты, готовые к отправке, будут
писаться в очередь - канал - и любой свободный поток на отправку будет
отправлять пакет.

Чтоб это было возможно, надо проверять, пишем мы условно в новый чат или
нет. Поэтому в тестовом режиме создаем хэш-таблицу, где ключ - это ~id~
юзера, с которым ведется чат, а значение - ~true~. Юзаем хэш-таблицу,
потому что она позволяет находить эементы за O(1) шагов в отличие от
массива.

#+NAME: _ChatTable
#+BEGIN_SRC go :noweb yes
  var ChatTable = make(map[int]bool)
#+END_SRC

#+NAME: _IsItNewChat
#+BEGIN_SRC go :noweb yes
  func IsItNewChat ( id int ) bool {
      _, found := ChatTable[id]
      return found
  }
#+END_SRC

Если чат уже создан, то просто помещаем пакет в очередь. Если
нет то:

- создаем запись в хэш-таблице
- создаем новую пару потоков
- кладем пакет в очередь
- проверяем статус клиента: он сигнализирует о том, хочет ли юзер выйти в
  оффлайн. Пока что просто тестовый вариант, чтоб не убивать прогу
  аварийно.
#+NAME: _main
#+BEGIN_SRC go :noweb yes :tangle client.go
  <<_IsItNewChat>>
  <<_getInput>>
  <<_testSerialDeserial>>
  func main () {

      // Tests ()

      err := GetClientId()

      if err != nil {
          fmt.Printf( " Didn't get client id: ", err.Error(), "\n" )
          os. Exit(1)
      }

      connect, err := ConnectToServer()

      if err != nil {
          fmt.Printf( "\n Connection failed, exit \n" )
          os. Exit(1)
      }

      fmt.Printf( " Have a connection with server \n" )
      // var wg sync.WaitGroup
      SendPackageQueue := make( chan sendPackage, 100 )
      SendLastPackageResult := make( chan bool, 100 )

      for {
          input, clientStatus := getInput()
          SendPack, err := makePackage( input, clientStatus )

          if err == nil {
              found := IsItNewChat ( SendPack.UserID )

              if found == false {
                  go sendMessage( connect, SendPackageQueue, SendLastPackageResult )
                  go getMessage( connect )
                  // go sendMessage( connect, &wg, SendPackageQueue )
                  // wg.Add(1)
                  // go getMessage( connect, &wg )
                  // wg.Add(1)
                  // wg.Wait()
              }
              SendPackageQueue <- SendPack
          }
          // клиент решил выйти из чата
          if clientStatus == -5 {
              result:= <- SendLastPackageResult
              if result == true {
                  break
              }
          }
      }
  }
#+END_SRC

Функция ~getMessage~:
- принимает пакет
- десериализует пакет
- проверяет его статус
- если статус 0, то печатает сообщение
- если нет, ошибка должна быть обработана

[TODO:gmm] Написать обработчик ошибок доставки.

#+NAME: _getMessage
#+BEGIN_SRC go :noweb yes
  <<_checkSendStatus>>
  <<_failedStatus>>
  <<_printRecievedMessage>>

  //принимает сообщения
  // func getMessage( connect *net.TCPConn,  wg *sync.WaitGroup ) int {
  func getMessage( connect *net.TCPConn ) int {
      getBuf := make( []byte, packSize )

      for {
          len, err := connect.Read( getBuf )

          if err == nil {
              pack, err := deserialization( getBuf [:len] )

              if err == nil && 0 == checkSendStatus( pack.SendStatus, pack.UserID ) {
                  printRecievedMessage ( pack.UserID, pack.Message )
              }
          }
      }
      // wg.Done()
      return 0
  }
#+END_SRC

Проверяет статус пакета:

#+NAME: _checkSendStatus
#+BEGIN_SRC go :noweb yes
  func checkSendStatus( SendStatus int, UserID int ) int {

      if SendStatus == -1 {
          failedStatus( UserID )
          return -1
      }
      return 0
  }
#+END_SRC

Печатает сообщение об ошибке, если статус ~failed~:

#+NAME: _failedStatus
#+BEGIN_SRC go :noweb yes
  func failedStatus ( userID int ) {

      fmt.Printf("Сообщение пользователю c id %d не было доставлено\n", userID);
  }
#+END_SRC

Печатает пришедшее сообщение, если все ок:

#+NAME: _printRecievedMessage
#+BEGIN_SRC go :noweb yes
  func printRecievedMessage ( UserID int, buf []string ) {
      fmt.Printf( "Получено сообщение от пользователя %d:  \n", UserID )

      for i := range buf {

          if buf[i] == "" {
              break
          }
          fmt.Println( buf[i] )
      }
      return
  }
#+END_SRC


Функция ~sendMessage~:

- формирует пакет
- сериализует его
- посылает в соединение
#+NAME: _sendMessage
#+BEGIN_SRC go :noweb yes
  // посылает сообщения
  // func sendMessage( connect *net.TCPConn, wg *sync.WaitGroup, ch chan SendPackage ) int {

  func sendMessage( connect *net.TCPConn, ch chan sendPackage, ch2 chan bool ) int {
      for {
          pack := <- ch
          buf, err := serialization( &pack )

          if err == nil {
               len, err := connect.Write(buf)

               if err != nil {
                   fmt.Printf("Cann't send: %s \n", err.Error())
               } else {
                   fmt.Printf("Bytes sent: %d \n", len)
                   if pack.SendStatus == -5 {
                       ch2 <- true
                   }
               }
           }
      }
      // wg.Done()
      return 0
  }
  <<_serialization>>
#+END_SRC

Методы ~read~ и ~write~, которые позволяют писать в соединение и читать
из него, принимают только слайсы в качестве аргументов. Это значит, что
придется делать сериализацию и десериализацию, чтоб принимать и
отправлять пакеты, имеющую выше описанную структуру:

#+NAME: _serialization
#+BEGIN_SRC go :noweb yes
  func serialization( pack *sendPackage ) ( []byte, error )  {

      buf, err:= json.Marshal( pack )

      if err != nil {
          fmt.Printf(" \n Cound'n serialize data: ", err.Error(), "\n" )
      }
      return buf, err
  }
  <<_deserialization>>
#+END_SRC

#+NAME: _deserialization
#+BEGIN_SRC go :noweb yes
  func deserialization( buf []byte ) ( sendPackage, error )  {

      pack := sendPackage{}
      err:= json.Unmarshal( buf, &pack )

      if err != nil {
          fmt.Printf(" \n Cound'n deserialize data: ", err.Error(), "\n" )
      }
      return pack, err
  }

#+END_SRC

Тесты:

#+NAME: _Tests
#+BEGIN_SRC go :noweb yes
  func Tests () {

      getInput ()
      testSerialDeserial()
  }
#+END_SRC


#+NAME: _testSerialDeserial
#+BEGIN_SRC go :noweb yes
  func testSerialDeserial() {

      input, status := getInput()

      fmt.Scan(&input)
      fmt.Printf("Read: %s \n", input)

      pack, err := makePackage( input, status )
      if err == nil {
          fmt.Printf("Msg before serialization: %s \n", pack.Message)

          buf, err := serialization( &pack )

          if err != nil {
              fmt.Printf("Serialization Test failed\n")
          } else {
              pack2, err := deserialization( buf )

              if err != nil {
                  fmt.Printf("Deserialization Test failed\n")

              } else {
                  fmt.Printf("Msg after serialization %s \n", pack2.Message)
              }
          }
      }
      return
  }

      <<_Tests>>
#+END_SRC

[TODO:gmm] Придумать, как сделать разные окна для чатов.
В каждом окне должно отражаться имя юзера и история переписки с
ним. Видимо, это придется делать на вебе.

** Сервер

Подключенные пакеты:

#+NAME: _servPackeges
#+BEGIN_SRC go :noweb yes :tangle server.go
  package main

  import (
      "fmt"
      "net"
      "os"
      "encoding/json"
      "sync"
      // "io"
  )

  <<_sendPackage>>
  <<_servConnection>>
#+END_SRC

Сервер должен быть способен разослать пакет от любого клиента любому
клиенту. Для этого ему нужно связать id клиента с его структурой
соединения: получая пакет от какого-то клиента, сервер будет его
десериализовать, читать ~id~ клиента, которому предназначен пакет, и
находить по этому ~id~ его стрктуру соединения, сериализовать пакет и
отправлять в нужное соединение.

Структура соединения на сервере:
- id клиента - по умолчанию -1
- его структура ~conn~, по умолчанию nil

#+NAME: _servConnection
#+BEGIN_SRC go :noweb yes
  type connection struct {

      ClientID int
      Connect *net.TCPConn
  }

<<_servConsts>>
#+END_SRC

Константы:

#+NAME: _servConsts
#+BEGIN_SRC go :noweb yes
  const (
      testUserID = 25
      packSize = 1000
      msgSizeStrings = 10
  )

  <<_servConnectionsTable>>
#+END_SRC

Эффективнее всего хранить соединения и их id в хэш-таблице: сложность на
вставку, удаление или поиск элемента - это O(n). Ключ - это id, значение -
структура ~conn~.

Глобальная переменная, разделяемый ресурс для потоков, осторожно!
#+NAME: _servConnectionsTable
#+BEGIN_SRC go :noweb yes
  var ConnectionsTable = make(map[int]*net.TCPConn)
  <<_servAliveAndNew>>
#+END_SRC

Создадим отдельный поток, который будет отвечать за регистрацию новых
пользователей на сервере.

В качестве параметров он принимает 2 канала: из  первого он читает
заполненые структуры соединений, которые преобразует в новые записи
хэш-таблицы, а во второй отправляет ~true~,  если вставка новой записи
удалась. Таким образом у нас есть способ сообщить другим потокам, что
запись прошла успешно.

#+NAME: _servRegisterNewClient
#+BEGIN_SRC go :noweb yes :tangle server.go
  func RegisterNewClient( ch chan connection, ch2 chan bool ) {

      for {
          newConnection, ok := <- ch

          // канал закрыт?
          if ok == false {
              break
          }
          // сохранить нового клиента
          ConnectionsTable[newConnection.ClientID] = newConnection.Connect

          // проверяем, что действительно сохранилось
          _, found := ConnectionsTable[newConnection.ClientID]

          if found == true {
              fmt.Println("RegisterNewClient: зарегестрирован новый клиент  ",
                  newConnection.ClientID,  newConnection.Connect )
              // сигнализируем, что закончили
              ch2 <- found
          }
      }
      return
  }
  <<_serialization>>
#+END_SRC

Алгоритм работы сервера.
Открываем сокет на "прослушку". Если все ок, то :
- создаем два канала: один, чтоб посылать ~RegisterNewClient~ структуры
  соединений, другой, чтоб она могла сигнализировать, когда закончит
  вставку.
- вызываем горутину с ~RegisterNewClient~
- вызываем прослушку сокета в бесконечном на предмет новых соединений
- вызываем ~IsAnyClientOnline~, которая должна мониторить, чтоб хотя бы
  один клиент был онлайн. В противном случае она вызовет завершение
  сервера. Из-за того, что прослушка новых соединений происходит в
  бесконечном цикле, то сервер приходится вырубать аварийно каждый раз.

#+NAME: _servOpenListener
#+BEGIN_SRC go :noweb yes :tangle server.go
  func openListener( wg *sync.WaitGroup ) int {
      service := "localhost:3425"
      tcpAddr, err := net.ResolveTCPAddr("tcp", service)
      l, err := net.ListenTCP("tcp", tcpAddr)

      if err != nil {
          fmt.Println("Server: listening error", err.Error())
          os.Exit(1)

      } else {
          registerClientsChan := make( chan connection, 100 )
          registerClientsChanResult := make( chan bool )
          countClientsChan := make( chan string, 100 )
          go RegisterNewClient( registerClientsChan, registerClientsChanResult )
          go countClients( countClientsChan )
          go IsAnyClientOnline( wg )
          go AcceptNewConnections( l, registerClientsChan, registerClientsChanResult,
              countClientsChan )
          // отслеживаем поток с AcceptNewConnections
           wg.Add(1)

      }
      return 0
  }

  <<_servAcceptNewConnections>>
  <<_servCountClients>>
#+END_SRC

Слушает сокет на предмет новых соединений.

Если новое соединение есть, вызывает ~getMessege~, который будет слушать
соединение на предмет новых пакетов. Ему передается: структура
соединения, два канала для общения с ~RegisterNewClient~ и канал для
общения с ~countClients~, которая ведет подсчет живых и отключившихся
клиентов. Это нужно, чтоб сервер мог корректно завершиться в случае, если
все клиенты отключились.

Есть механизмы синхронизации - пакет ~sync~, который позволяет
синхронизировать таким образом потоки, чтоб один поток дождилася
завершеия других. Для этого заводится счетчик потоков ~wg
sync.WaitGroup~, при каждом запуске нового потока он увеличивается,
когда поток завершается, то он вызывает ~wg.Done()~, который уменьшает
этот счетчик. А вызов ~wg.Wait()~ в галвном потоке позволяет ждать до тех
пор, пока не завершатся все прочие потоки.
Но поскольку у нас прослушка сокета идет в бесконечном цикле, то мы тупо
зависнем на ~wg.Wait()~.

Поэтому приходится реализовать механизм вручную.

#+NAME: _servAcceptNewConnections
#+BEGIN_SRC go :noweb yes
  func AcceptNewConnections( l *net.TCPListener, ch chan connection, ch2 chan bool,
                             ch3 chan string ) {
      fmt.Println(" SERVER RUNS \n")

      for {

          conn, err := l.AcceptTCP()

          if err != nil {
              fmt.Println("Accept error", err.Error())
              os.Exit(1)
          }
          go getMessege( conn, ch, ch2, ch3 )
          ch3 <- "new"
      }
  }
#+END_SRC

~getMessege~ принимает пакеты из конкретного соединения. Каждое
соединение обладает своим собственным буфером, куда пишутся и откуда
читаются сообщения. Так же есть переменная ~remembered~: по
умолчанию 0. Если выставлена в 1, то соединение уже зарегестрировано в
хэш-таблице.

Проблема в том, что мы не можем зарегать нового клиента до тех пор, пока
он ен отправит первый пакет: нам не известен его уникальный ~id~, при
подключении известна только структура его соединения.

Поэтому алгоритм работы такой:
- получили сообщение
- если ~remembered~ == 0, значит, соединение еще не зарегано:
  - десериализуем пакет (функция десериализации та же, что и на клиенте)
  - читаем из структуры пакета id клиента, который его отправил
  - формируем из него и структуры соединения ~conn~ структуру соединения
  - шлем ее в канал ~RegisterNewClient~
  - дожидаемся, пока придет ответ, что все ок (так мы предохраняемся от
    ситуации, когда юзер хочет отправить сообщения сам себе, но он еще не
    зареган на сервере. Если не дождаться ответа от ~RegisterNewClient~,
    то юзеру придет ошибка, что ему не удалось отправить сообщение самому
    себе, по причине, что его не существует как зареганного клиента (что
    полный бред)
  - если все ок, меняем значение ~remembered~ на единицу
- вызываем отправку сообщения сообщение

#+NAME: _servGetMessege
#+BEGIN_SRC go :noweb yes :tangle server.go
  func getMessege( connect *net.TCPConn, ch chan connection, ch2 chan bool,
                   ch3 chan string ) {

      remembered := 0
      buf := make([]byte, packSize)

      for {
          len, err := connect.Read( buf )

          if err == nil {
              fmt.Printf("message recieved, len %d bytes \n", len );

              if remembered == 0 {
                  pack, err := deserialization( buf[:len] )

                  // отправить данные клиента на регистрацию
                  if err == nil {
                      newConnection:= connection{ ClientID: pack.MyID,
                          Connect:  connect }
                      ch <- newConnection

                      // регистрация законцена?
                      finished :=  <- ch2
                      if finished == true {
                          remembered = 1
                      }
                  }
              }
              sendMessege( connect, buf, len, ch3 )
          }
      }
      return
  }

  <<_servSendMessege>>
#+END_SRC

~sendMessege~ отправляет сообщение. В качестве параметра принимает
структуру соединения, буфер, в который был считан полученный пакет,
размер пакета в байтах и канал для общения с ~IsAnyClientOnline~

Алгоритм:
- десериализовать буфер - вернее, только то кол-во байт, которое было
  прочитано из соединения. Если попытаться десериализовать весь буфер, то
  его незаполненная часть будет заполнена символом ~\x00~ и метод
  ~json.Unmarshal~ выдаст ошибку
- если все ок, то:
  - проверить, существует ли юзер, которому хотим отправить сообщение:
    запрашиваем значение по ключу id изхэш-таблицы напрямую.

    [TODO:gmm] сделать доступ к таблице через канал. Хотя значения в ней не
    перезаписываются, но дополняются новыми. В результате может возникнуть
    ситуация, когда в одно и то же время один поток пишет значени в таблицу,
    регистрируя нового клиента, а другой - пытается получить запись этого
    клиента, чтоб отравить ему сообщение.

   - если запись найдена:
    - сериализуем пакет (функция сериализации та же, что на клиенте)
    - отпарвляем в соединение
    - проверяем ошибку, если есть
  - проверяем статус клиента: если клиент хочет выйти, отправляем в канал
    ~IsAnyClientOnline~ строку "quit"
  - иначе отправляем в то же соединение, из которого пришел пакет, этот
    же пакет со статусом отправки -1

#+NAME: _servSendMessege
#+BEGIN_SRC go :noweb yes
  <<_servCheckErrorSendMessage>>

  func sendMessege( myConnect *net.TCPConn, buf []byte, len int,
                    ch chan string ) {

      pack, err := deserialization( buf[:len] )

      if err == nil {

          status := pack.SendStatus

          // проверяем существование юзера, которому
          // отправляем сообщение
          connectUser, found := ConnectionsTable[pack.UserID]
          fmt.Println("found ", found )

          // нашли
          if found == true {
              fmt.Println("connectUser ", connectUser )
              sendBuf, err := serialization( &pack )
              len, err := connectUser.Write( sendBuf )
              checkErrorSendMessage( err, len)
              if status == -5 {
                  fmt.Printf("sendMessege: send 'quit' \n")
                  ch <- "quit"
              }

          // не нашли
          } else {
              pack.SendStatus = -1
              sendBuf, err := serialization( &pack )
              len, err := myConnect.Write( sendBuf )
              checkErrorSendMessage( err, len)
              if status == -5 {
                  fmt.Printf("sendMessege: send 'quit' \n")
                  ch <- "quit"
              }

          }
      }
      return
  }

  <<_servMain>>
#+END_SRC

Проверяет ошибку отправки:
#+NAME: _servCheckErrorSendMessage
#+BEGIN_SRC go :noweb yes
  func checkErrorSendMessage( err error, len int ) {
      if err != nil {
          fmt.Printf("Cann't send: %s \n", err.Error())
      } else {
          fmt.Printf("Bytes sent: %d \n", len)
      }
      return
  }
#+END_SRC

Теперь, собственно, создаем ~IsAnyClientOnline~, которая мониторит, есть
ли хоть один живой клиент, две глобальные переменне: ~alive~ и ~new~ и
~countClients~, которая ведет подсчет клиентов:

#+NAME: _servAliveAndNew
#+BEGIN_SRC go :noweb yes
  var alive int
  var new int
#+END_SRC

~countClients~ принимает в качестве аргумента канал, по которому от
дургих потоков ей приходят сообщения.
Если пришло сообщение ~"new"~ , значит зарегистрирован новый
пользователь. Тогда значение ~alive~ и ~new~ инкрементируется. Если
приходит сообение ~quit~, то ~alive~ декрементируется.

#+NAME: _servCountClients
#+BEGIN_SRC go :noweb yes
  func countClients ( ch chan string ) {
      fmt.Printf("countClients\n")
      for {
          msg := <- ch
          if msg == "new" {
              fmt.Printf("countClients: read 'new' \n")
              alive += 1
              new += 1
          } else if msg == "quit" {
              fmt.Printf("countClients: read 'quit' \n")
              alive -= 1
          }
      }
  }
  <<_servIsAnyClientOnline>>
#+END_SRC

Эта функция проверяет, онлайн ли хоть один клинт: если кол-во всех
зареганных клиентов (new) больше "живых" клиентов и кол-во живых клиентов
= 0, то вызываем ~wg.Done()~, который просигнализирует функции ~main~,
что поток, который случае новые соединения типа завершился (на самом деле
нет, но нам пофиг). ~main~ прекратит ждать этот поток и сервер завершит
работу.
#+NAME: _servIsAnyClientOnline
#+BEGIN_SRC go :noweb yes
  func IsAnyClientOnline ( wg *sync.WaitGroup ) {
      for {
          if new > alive && alive == 0 {
              wg.Done()
              break
          }
      }
  }
#+END_SRC

Вызываем процесс из ~main~:

#+NAME: _servMain
#+BEGIN_SRC go :noweb yes

  func main () {
      var wg sync.WaitGroup
      openListener( &wg )
      wg.Wait()
      return
  }

#+END_SRC

** Автоматические тесты
Тесты должны проверить работоспособность мессенджера.
- запустить сервер
- запустить n клиентов с их уникальными id (пусть это будут номера от 0 до n -1)
- каждый клиент должен:
  - отправить сообщение самому себе
  - отправить сообщение существующему клиенту
  - отправить сообщение несуществующему клиенту
  - выйти
- когда все клиенты просигнализировали о выходе, отключить сервер
